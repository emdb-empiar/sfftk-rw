# -*- coding: utf-8 -*-
from __future__ import division, print_function

"""
========================
sfftkrw.schema.base
========================

This adapter API therefore specifies two main base classes from which all other classes are built upon:

The :py:class:`SFFType` Base Class
==================================

This class contains all the magic to convert a subclass definition into a user-level class. View the
API documentation of this class for details on its attributes.

The :py:class:`SFFAttribute` Descriptor Class
================================================

Attributes of subclasses of :py:class:`SFFType` are instances of this descriptor class.

In addition to the two above classes there is a :py:class:`SFFTypeError` class which is raised whenever a type error
occurs which provides details on the required type.

The :py:class:`SFFIndexType` Base Class
================================================

TBA

The :py:class:`SFFListType` Base Class
================================================

TBA

"""
import numbers
import os

import h5py

from .. import VALID_EXTENSIONS
from ..core import _dict, _str
from ..core.print_tools import print_date
from ..schema import emdb_sff as sff


class SFFTypeError(Exception):
    """`SFFTypeError` exception"""

    def __init__(self, instance, klass, message=None):
        self.instance = instance
        self.klass = klass
        self.message = message

    def __str__(self):
        if self.message is None:
            return repr("'{}' is not object of type {}".format(self.instance, self.klass))
        else:
            return repr("'{}' is not object of type {}: {}".format(self.instance, self.klass, self.message))


# fixme: correct documentation
class SFFType(object):
    """Base class for all EMDB-SFF adapter classes

    This class reads and configures any subclass using the subclass' definition.

    Subclasses of :py:class:`SFFType` should define class attributes from the following list depending on whether
    the subclass defines a container or not. Containers typically have *List* in the class name signifying that they
    are a *list* of objects of some type. For example, the :py:class:`SFFSegmentList` objects are a *list of*
    :py:class:`SFFSegment` objects.

    :param var: argument value determines what the subclass does

    The :py:class:`type` of ``var`` determines what the subclass does.

    -   If the subclass is :py:class:`SFFSegmentation` then if ``var`` is:

        -   :py:class:`None` it will produce an empty :py:class:`SFFSegmentation` object

        -   an ``emdb_sff.segmentation`` object it will produce a populated :py:class:`SFFSegmentation` object;

        -   :py:class:`str` it will try to treat ``var`` as a filename containing data to populate an
            :py:class:`SFFSegmentation` object; the extension of the filename determines the format to be read:

            -   ``*.sff`` will read as XML

            -   ``*.hff`` will read as HDF5

            -   ``*.json`` will read as JSON

    -   If the subclass is any other class then if ``var`` is:

        -   :py:class:`None` it will produce an empty object of that class e.g. ``SFFSoftware()`` will produce an empty
            object for defining software data

        -   :py:class:`None` (or excluded) but keyword arguments to the generated generateDS class are specified it will
            produce a populated object of the corresponding adapter class e.g.
            ``SFFSoftware(name="name", version="version", processingDetails="details")`` will be an object loaded with
            the keyword data;

        -   any ``emdb_sff`` object it will produce a populated object of the corresponding adapter class;




    .. py:attribute:: gds_type

        The class generated by generateDS (*generate ds type*) that this class adapts

    .. py: attribute:: ref

        The *reference* name for objects of the subclass

    .. py:attribute:: repr_str

        A *string representation* for objects of the subclass that can be formatted. This string will be produced
        for calls to the :py:func:`print` function. Formatting is accomplished by included empty format delimiters
        (``{}``) which will be populated with values from the :py:attr:`repr_args` specified below otherwise
        literal braces will be displayed.

    .. py:attribute:: repr_args

        The *arguments of the string representation*, if any. This is a tuple containing any combination of either:

        -   the names of attributes of the subclass to populate the the :py:attr:`repr_string` attribute;

        -   a literal text string;

        -   the string ``len()`` to include the length of the subclass

    .. py:attribute:: iter_attr

        The *iterable attribute* of the class. It refers to an attribute of the class pointed to by
        :py:attr:`gds_type` which is iterable.

        It should be a two-tuple having the name of the generateDS class and ``SFF*`` class to adapt it to.

        Only one attribute per class can be specified.

        For example, consider the following class definition for some fictional ``SFFTest`` class that adapts a class
        called ``test`` that was generated by generateDS.

        .. code:: python

            import emdb_sff

            class SFFTest(SFFType):
                gds_type = emdb_sff.test
                repr_str = "SFFTest object with {} SFFItem objects inside"
                repr_args = ("len()",)
                iter_attr = ('i', SFFItem)

                # attributes
                items = SFFAttribute('items', sff_type=SFFItem)

        In this sample:

        -   the generateDS API is located in the module called ``emdb_sff``;

        -   ``test`` is a class in the ``emdb_sff`` module;

        -   ``i`` is an iterable attribute of ``test``;

        -   ``i`` is adapted by the ``SFFItem`` class (which should have its :py:attr:`gds_type` set to the class for
            ``i``);

        Now consider this class in action:

        .. code:: python

            from sfftkrw.schema import SFFTest

            T = SFFTest()
            # ...
            # populate T with some valid data
            # ...
            # now we can iterate over the data
            for i in T: # because it has an iter_attr specified
                # i is an SFFItem object
                print(i)
                # prints 'SFFTest object with 37 SFFItem objects inside'

        In addition to being iterable, the iterable attribute enable the following operations on objects of the
        subclass:

        -   length i.e. len(obj);

            .. code:: python

                len(T)
                # 37

        -   indexing e.g. ``obj[<int>]``;

            .. code:: python

                T[15]
    """
    gds_type = None
    ref = ""
    repr_string = ""
    repr_args = ()
    iter_attr = ()
    iter_dict = None  # previously was _dict()

    def __init__(self, *args, **kwargs):
        """Base initialiser

        The top-level class has three forms
        #1 - SFFSegmentation() # empty segmentation object
        #2 - SFFSegmentation(emdb_sff.segmentation, *args, **kwargs) # build a segmentation object from an emdb_sff.segmentation object

        All other classes have two forms (e.g. SFFSoftware):
        #1 - SFFSoftware() # empty software object
        #2 - SFFSoftware(emdb_sff.softwareType) # build a software object from an emdb_sff.softwareType object
        #3 - SFFSoftware(name="name", version="version", processingDetails="details") # use gds_type kwargs

        """
        if self.gds_type:
            # restructure kwargs of type SFF* to their gds_type equivalents
            _kwargs = _dict()
            for k in kwargs:
                if isinstance(kwargs[k], SFFType):
                    _kwargs[k] = kwargs[k]._local
                # todo: keep an eye open for this
                # fixme: 'new_obj' should not crop up as a kwarg
                elif k == 'new_obj':
                    continue
                else:
                    _kwargs[k] = kwargs[k]
            self._local = self.gds_type(*args, **_kwargs)  # 1 and #3 - SFFType from (*a, **kw)
            # ensure that the version is copied without requiring user intervention
            if isinstance(self._local, sff.segmentation):
                self.version = self._local.schemaVersion
        else:
            raise ValueError("attribute 'gds_type' cannot be 'None'")
        # load dict
        # self._load_dict()

    @classmethod
    def from_gds_type(cls, inst):
        """Create an `SFFType` subclass directly from a `gds_type` object

        Notice that we ignore do not pass `*args, **kwargs` as we assume the `inst` is complete.
        """
        if isinstance(inst, cls.gds_type):
            obj = cls(new_obj=False)
            obj._local = inst
        else:
            raise SFFTypeError(inst, cls)
        return obj

    def __repr__(self):
        return self.ref

    def __str__(self):
        if self.repr_string:
            if self.repr_args:
                assert isinstance(self.repr_args, tuple)
                if len(self.repr_args) == self.repr_string.count('{}'):
                    repr_args = list()
                    for arg in self.repr_args:
                        if arg == 'len()':
                            repr_args.append(len(self))
                        else:
                            repr_args.append(getattr(self, arg, None))
                    return self.repr_string.format(*repr_args)
                else:
                    raise ValueError("Unmatched number of '{}' and args in repr_args")
            else:
                return self.repr_string
        else:
            return str(type(self))

    def __eq__(self, other):
        raise NotImplementedError  # by default; force explicit comparison

    # def _load_dict(self):
    #     if self.iter_attr and self.iter_dict is not None:
    #         self.iter_dict = _dict()  #  initialise
    #         for item in self:
    #             if isinstance(item, SFFType):
    #                 self.iter_dict[item.id] = item
    #             elif isinstance(item, int):  # applies to vertices
    #                 self.iter_dict[item] = item
    #             elif isinstance(item, _basestring):  # applies to complexes and macromolecules
    #                 self.iter_dict[item] = item
    #             else:
    #                 raise ValueError("Unknown class {}".format(type(item)))

    # def get_ids(self):
    #     """If the subclass is a container class, returns a list of IDs for items contained
    #
    #     :return: a list of IDs
    #     :rtype: int
    #     """
    #     if self.iter_attr:
    #         return self.iter_dict.keys()
    #
    # def get_by_id(self, item_id):
    #     """If the subclass is a container class, returns the object of the specified ID
    #
    #     :param int item_id: the ID whose item is required
    #     :return: a contained object
    #     :rtype: depends on the container class
    #     :raises ValueError: if the item is not found
    #     """
    #     if self.iter_attr:
    #         if item_id in self.iter_dict:
    #             return self.iter_dict[item_id]
    #         else:
    #             raise ValueError("ID {} not found".format(item_id))

    def export(self, fn, *_args, **_kwargs):
        """Export to a file on disc

        :param str fn: filename to export to; the output format is determined by the extension:

        - ``.sff`` - XML
        - ``.hff`` - HDF5
        - ``.json`` - JSON
        """
        fn_ext = fn.split('.')[-1]
        try:
            assert fn_ext in VALID_EXTENSIONS
        except AssertionError:
            print_date("Invalid filename: extension should be one of {}: {}".format(
                ", ".join(VALID_EXTENSIONS),
                fn,
            ))
            return os.EX_DATAERR
        if fn_ext == 'sff':
            with open(fn, 'w') as f:
                # write version and encoding
                version = _kwargs.get('version') if 'version' in _kwargs else "1.0"
                encoding = _kwargs.get('encoding') if 'encoding' in _kwargs else "UTF-8"
                f.write('<?xml version="{}" encoding="{}"?>\n'.format(version, encoding))
                # always export from the root
                self._local.export(f, 0, *_args, **_kwargs)
        elif fn_ext == 'hff':
            with h5py.File(fn, 'w') as f:
                self.as_hff(f, *_args, **_kwargs)
        elif fn_ext == 'json':
            with open(fn, 'w') as f:
                self.as_json(f, *_args, **_kwargs)
        return os.EX_OK

    def as_hff(self, f, *args, **kwargs):
        raise NotImplementedError

    def as_json(self, f, *args, **kwargs):
        raise NotImplementedError


class SFFIndexType(SFFType):
    """Mixin to handle object IDs"""
    index_attr = ""
    """the name of the attribute on the class which will be treated as the ID"""
    increment_by = 1
    """by default we increment by 1"""
    start_at = 0
    """used when resetting `index_attr` attribute"""
    index_in_super = False
    """when an index is applied to a set of subclasses we set `index_in_super` to True"""

    @staticmethod
    def update_index(cls, obj, current, **kwargs):
        """Set the index value in `obj` and return the next value

        :param cls: the class of obj
        :param int current: the current value of the index
        :param obj: the instance
        :param kwargs: keyword arguments
        :return int next: the next value of the index
        """
        # set the index on the instance
        setattr(obj, cls.index_attr, current)
        # update the index
        if 'id' in kwargs:
            next = kwargs['id'] + cls.increment_by
        elif 'vID' in kwargs:
            next = kwargs['vID'] + cls.increment_by
        elif 'PID' in kwargs:
            next = kwargs['PID'] + cls.increment_by
        else:
            next = current + cls.increment_by
        return next

    def __new__(cls, new_obj=True, *args, **kwargs):
        # make sure we have a non-blank `index_attr` in the class
        try:
            assert cls.index_attr
        except AssertionError:
            raise SFFTypeError(cls.index_attr, str, 'subclasses must provide an index attribute')
        # make sure there is an attribute with the value of the `index_attr` string
        try:
            assert hasattr(cls, cls.index_attr)
        except AssertionError:
            raise AttributeError("'{}' is missing a class variable '{}'".format(cls, cls.index_attr))
        # make sure the `index_attr` attribute is set to an integer
        try:
            assert isinstance(getattr(cls, cls.index_attr), numbers.Integral)
        except AssertionError:
            raise SFFTypeError(cls.index_attr, numbers.Integral)
        # create the instance
        obj = super(SFFIndexType, cls).__new__(cls)
        if new_obj:
            # current index
            current = getattr(cls, cls.index_attr)
            # if the index is in the superclass
            if obj.index_in_super:
                try:
                    assert hasattr(cls, 'update_counter')
                except AssertionError:
                    raise AttributeError("{} superclass does not have an 'update_counter' classmethod".format(cls))
                next = SFFIndexType.update_index(cls, obj, current, **kwargs)
                # update the index attr
                cls.update_counter(next)
            else:
                next = SFFIndexType.update_index(cls, obj, current, **kwargs)
                # update the index attr
                setattr(cls, cls.index_attr, next)
        return obj

    def __init__(self, *args, **kwargs):
        # we don't want the `new_obj` kwarg to propagate so we terminate it here
        if 'new_obj' in kwargs:
            # only set the `index_attr` to None if `new_obj=False`
            if not kwargs['new_obj']:
                setattr(self, self.index_attr, None)
            del kwargs['new_obj']
        super(SFFIndexType, self).__init__(*args, **kwargs)
        # todo: if I want to add a new segment to a set of available segments does the id begin at the right value?
        # id
        if 'id' in kwargs:
            self._local.id = kwargs['id']
        else:
            self._local.id = getattr(self, self.index_attr)
        # vID: vertices
        if 'vID' in kwargs:
            self._local.vID = kwargs['vID']
        else:
            self._local.vID = getattr(self, self.index_attr)
        # PID: polygons
        if 'PID' in kwargs:
            self._local.PID = kwargs['PID']
        else:
            self._local.PID = getattr(self, self.index_attr)

    @classmethod
    def reset_id(cls):
        """Reset the `index_attr` attribute to its starting value"""
        setattr(cls, cls.index_attr, cls.start_at)


class SFFListType(SFFType):
    """Mixin to confer list-like behaviour"""
    iter_attr = None

    def __init__(self, *args, **kwargs):
        # make sure `iter_attr` is not empty
        try:
            assert self.iter_attr
        except AssertionError:
            raise ValueError("attribute 'iter_attr' in {} cannot be empty".format(self))
        # make sure `iter_attr` consists of a string and a class
        try:
            assert isinstance(self.iter_attr[0], _str)
        except AssertionError:
            raise SFFTypeError(self.iter_attr[0], _str)
        try:
            assert issubclass(self.iter_attr[1], SFFType) or self.iter_attr[1] == _str or self.iter_attr[1] == int
        except AssertionError:
            raise SFFTypeError(self.iter_attr[1], SFFType)
        # reset ID only if `self.iter_attr` is an `SFFType` subclass
        if issubclass(self.iter_attr[1], SFFType):
            self.iter_attr[1].reset_id()
        super(SFFListType, self).__init__(*args, **kwargs)

    def __iter__(self):
        """When we iterate over subclasses we want to recast back from generateDS types to
        adapter types.

        For values which remain as native Python types (strings and integers) we perform
        a simple type cast.
        """
        iter_name, iter_type = self.iter_attr
        if issubclass(iter_type, SFFType):
            return iter(list(map(iter_type.from_gds_type, getattr(self._local, iter_name))))
        else:
            return iter(list(map(iter_type, getattr(self._local, iter_name))))

    def __len__(self):
        iter_name, _ = self.iter_attr
        return len(getattr(self._local, iter_name))

    def __getitem__(self, index):
        iter_name, iter_type = self.iter_attr
        if issubclass(iter_type, SFFType):
            return iter_type.from_gds_type(getattr(self._local, iter_name)[index])
        else:
            return iter_type(getattr(self._local, iter_name)[index])

    def __setitem__(self, index, value):
        iter_name, iter_type = self.iter_attr
        # get the container
        cont = getattr(self._local, iter_name)
        if iter_type not in [_str, int] and isinstance(value, iter_type):
            cont[index] = value._local
        elif iter_type in [_str, int] and (isinstance(value, _str) or isinstance(value, int)):
            cont[index] = value
        else:
            raise SFFTypeError(value, iter_type, "or int or str")

    def __delitem__(self, index):
        iter_name, _ = self.iter_attr
        # get the name of the iterable in _local (a list) then delete index pos from it
        del getattr(self._local, iter_name)[index]

    def append(self, item):
        """Append to the list"""
        iter_name, iter_type = self.iter_attr
        cont = getattr(self._local, iter_name)
        if iter_type not in [_str, int] and isinstance(item, iter_type):
            cont.append(item._local)
        elif iter_type in [_str, int] and (isinstance(item, _str) or isinstance(item, int)):
            cont.append(item)
        else:
            raise SFFTypeError(item, SFFType, "or int or str")

    def clear(self):
        """Remove all items"""
        iter_name, _ = self.iter_attr
        cont = getattr(self._local, iter_name)
        cont.clear()

    def copy(self):
        """Create a shallow copy"""

    def extend(self, other):
        """Make a new list using this and other"""
        try:
            assert isinstance(other, type(self))
        except AssertionError:
            raise SFFTypeError(other, type(self))
        iter_name, _ = self.iter_attr
        cont = getattr(self._local, iter_name)
        cont_other = getattr(other._local, iter_name)
        cont.extend(cont_other)

    def insert(self, index, item):
        """Insert into the list at the given index"""
        iter_name, iter_type = self.iter_attr
        cont = getattr(self._local, iter_name)
        if iter_type not in [_str, int] and isinstance(item, iter_type):
            cont.insert(index, item._local)
        elif iter_type in [_str, int] and (isinstance(item, _str) or isinstance(item, int)):
            cont.insert(index, item)
        else:
            raise SFFTypeError(item, SFFType, "or int or str")

    def pop(self, index=-1):
        """Remove and return the indexed (default: last) item"""
        iter_name, iter_type = self.iter_attr
        cont = getattr(self._local, iter_name)
        popped = cont.pop(index)
        if issubclass(iter_type, SFFType):
            return iter_type.from_gds_type(popped)
        else:
            return iter_type(popped)


    def remove(self, item):
        """Removes the first occurrence of item"""

    def reverse(self):
        """Reverses the items in place"""


class SFFDictType(SFFType):
    """Mixin to confer dictionary-like behaviour.

    Dictionary-like access is through the :py:meth:`get_by_id` method.
    """


class SFFAttribute(object):
    """Descriptor for SFFType subclass attributes

    This descriptor acts an adapter and references an attribute on the instance (obj._local).
    In this way, it guarantees that there is no overwriting of values because every instance will have a new _local
    instance to refer to.
    """

    def __init__(self, name, sff_type=None, get_from=None, set_to=None, del_from=None, help=""):
        """Initialiser for an attribute

        This class acts as an intermediary between ``SFFType`` and ``emdb_sff`` objects. Each ``SFFType``
        defines a ``_local`` attribute (defined from the ``gds_type`` class attribute, which points to
        the ``emdb_sff`` object.

        Occasionally, the name of the ``emdb_sff`` attribute is different from the ``SFFType`` attribute.
        In this cases, a ``get_from`` argument controls where in the ``emdb_sff`` object the data should
        be obtained from and the ``set_to`` argument controls which attribute in ``emdb_sff`` it should
        be set to. If both arguments are ``None`` (default) then get from the argument referred to by
        ``name``.

        :param str name: the name the attribute is referred to on the containing object
        :param sff_type: class of attribute (default: None - standard Python types like int, str, float)
        :param str get_from: which ``emdb_sff`` attribute to get the data from
        :param str set_to: which ``emdb_sff`` attribute to set the data to
        """
        self._name = name
        self.__doc__ = help
        self._sff_type = sff_type
        self._get_from = get_from
        self._set_to = set_to
        self._del_from = del_from

    def __get__(self, obj, _):  # replaced objtype with _
        if self._sff_type:
            if self._get_from:
                return self._sff_type.from_gds_type(getattr(obj._local, self._get_from, None))
            else:
                return self._sff_type.from_gds_type(getattr(obj._local, self._name, None))
        # if self._sff_type:
        #     if self._get_from:
        #         return self._sff_type(getattr(obj._local, self._get_from, None))
        #     else:
        #         return self._sff_type(getattr(obj._local, self._name, None))
        else:
            if self._get_from:
                return getattr(obj._local, self._get_from, None)
            else:
                return getattr(obj._local, self._name, None)

    def __set__(self, obj, value):
        if self._sff_type:
            if isinstance(value, self._sff_type):
                if self._set_to:
                    setattr(obj._local, self._set_to, value._local)
                else:
                    setattr(obj._local, self._name, value._local)
            else:
                raise SFFTypeError(value, self._sff_type)
        else:
            if self._set_to:
                setattr(obj._local, self._set_to, value)
            else:
                setattr(obj._local, self._name, value)

    def __delete__(self, obj):
        if self._del_from:
            delattr(obj._local, self._del_from)
        else:
            delattr(obj._local, self._name)
